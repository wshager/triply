{"version":3,"sources":["../src/chimp.js"],"names":["LEAF","BRANCH","CLOSE","isLeaf","node","$0","isBranch","isClose","create","props","type","Object","assign","$1","$2","$3","next","previous","nextSibling","isLastChild","previousSibling","isFirstChild","prev","traverse","start","firstChild","lastChild","_promote","closer","_demote","appendChild","ref","insertAfter","insertBefore","refIsBranch","isEmptyBranch","link","removeChild","child","remove"],"mappings":"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","sourcesContent":["/**\r\n * Type LEAF = 1\r\n * @type {Number}\r\n */\r\nexport const LEAF = 1;\r\n\r\n/**\r\n * Type BRANCH = 2\r\n * @type {Number}\r\n */\r\nexport const BRANCH = 2;\r\n\r\n/**\r\n * Type CLOSE = 3\r\n * @type {Number}\r\n */\r\nexport const CLOSE = 3;\r\n\r\n/**\r\n * Test if node is LEAF\r\n * @param  {Object}  node Node-formatted object\r\n * @return {Boolean}\r\n */\r\nexport const isLeaf = node => !!node && node.$0 === LEAF;\r\n\r\n/**\r\n * Test if node is BRANCH\r\n * @param  {Object}  node Node-formatted object\r\n * @return {Boolean}\r\n */\r\nexport const isBranch = node => !!node && node.$0 === BRANCH;\r\n\r\n/**\r\n * Test if node is CLOSE\r\n * @param  {Object}  node Node-formatted object\r\n * @return {Boolean}\r\n */\r\nexport const isClose = node => !!node && node.$0 === CLOSE;\r\n\r\n/**\r\n * Create a leaf node (branches and closes are created by the implementation).\r\n *\r\n * The following keys are reserved for formatting an object as a node:\r\n *\r\n * | Key  | Purpose                        |\r\n * | :--- | :----------------------------- |\r\n * | $0   | Type                           |\r\n * | $1   | Depth-first travsersal         |\r\n * | $2   | Reversed depth-first Traversal |\r\n * | $3   | BRANCH-to-CLOSE link           |\r\n *\r\n * @param  {Object} [props={}]  initial object\r\n * @param  {Number} [type=LEAF] node type\r\n * @return {Object}             node-formatted object\r\n */\r\nexport function create(props = {},type = LEAF) {\r\n\t// NOTE Actually, a LEAF never has $3...\r\n\treturn Object.assign({\r\n\t\t$0:type,\r\n\t\t$1:void 0,\r\n\t\t$2:void 0,\r\n\t\t$3:void 0\r\n\t},props);\r\n}\r\n\r\n/**\r\n * Get the node's next node in depth-first traversal\r\n * @param  {Object}   node      Node-formatted object\r\n * @return {Object|void}        Node (if have)\r\n */\r\nexport function next(node) {\r\n\treturn node.$1;\r\n}\r\n\r\n/**\r\n * Get the node's previous node in depth-first traversal\r\n * @param  {Object}   node      Node-formatted object\r\n * @return {Object|void}        Node (if have)\r\n */\r\nexport function previous(node) {\r\n\treturn node.$2;\r\n}\r\n\r\n/**\r\n * Get the node's nextSibling\r\n * @param  {Object}   node      Node-formatted object\r\n * @return {Object|void}        Node (if have)\r\n */\r\nexport function nextSibling(node) {\r\n\tif(isLastChild(node)) return;\r\n\treturn node.$0 === LEAF ? node.$1 : node.$3.$1;\r\n}\r\n\r\n/**\r\n * Get the node's previousSibling\r\n * @param  {Object}   node      Node-formatted object\r\n * @return {Object|void}        Node (if have)\r\n */\r\nexport function previousSibling(node) {\r\n\tif(isFirstChild(node)) return;\r\n\tconst prev = node.$2;\r\n\treturn prev.$0 === CLOSE ? prev.$3 : prev;\r\n}\r\n\r\n/**\r\n * Traverse node\r\n * @param  {Object}    node  Node-formatted object\r\n * @yields {Object}          Node-formatted object\r\n */\r\nexport function* traverse(node) {\r\n\t//if(isLeaf(node)) return yield node;\r\n\tconst start = node;\r\n\twhile(node) {\r\n\t\tyield node;\r\n\t\tif(node === start.$3) return;\r\n\t\tnode = node.$1;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Get the node's firstChild\r\n * @param  {Object}   node      Node-formatted object\r\n * @return {Object|void}        Node (if have)\r\n */\r\nexport function firstChild(node) {\r\n\tif(isBranch(node) && !isClose(node.$1)) return node.$1;\r\n}\r\n\r\n/**\r\n * Get the node's lastChild\r\n * @param  {Object}   node      Node-formatted object\r\n * @return {Object|void}        Node (if have)\r\n */\r\nexport function lastChild(node) {\r\n\tif(node.$0 === BRANCH) return node.$3.$2;\r\n}\r\n\r\n/**\r\n * Expand LEAF into BRANCH\r\n * @private\r\n * @param  {Object}   node      Node-formatted object\r\n * @return {Object}             Node-formatted object\r\n */\r\nfunction _promote(node) {\r\n\tnode.$0 = BRANCH;\r\n\t// add closer\r\n\tconst closer = node.$3 = create({},CLOSE);\r\n\t// point closer back to node\r\n\tcloser.$3 = node;\r\n\t// re-attach sibling to closer\r\n\tcloser.$1 = node.$1;\r\n\t// NOTE expect $1 to be overwritten\r\n\t// and $2 to stay the same\r\n\treturn node;\r\n}\r\n\r\n/**\r\n * Collapse BRANCH into LEAF\r\n * @private\r\n * @param  {Object}   node      Node-formatted object\r\n * @return {Object}             Node-formatted object\r\n */\r\nfunction _demote(node) {\r\n\tnode.$0 = LEAF;\r\n\t// re-attach sibling from closer\r\n\tnode.$1 = node.$3.$1;\r\n\t// delete closer\r\n\tdelete node.$3;\r\n\t// NOTE expect $2 to stay the same\r\n\treturn node;\r\n}\r\n\r\n/**\r\n * append child to node (promotes LEAF to BRANCH if needed)\r\n * @param  {Object} node Node-formatted object\r\n * @param  {Object} ref  Node-formatted object\r\n * @return {Object}      The appended child\r\n */\r\nexport function appendChild(node,ref) {\r\n\tif(ref.$0 == LEAF) {\r\n\t\tref = _promote(ref);\r\n\t\t// 1. attach node\r\n\t\tref.$1 = node;\r\n\t\t// 2. point node's $2 back to parent\r\n\t\tnode.$2 = ref;\r\n\t\t// 3. point node to ref's closer\r\n\t\tif(isLeaf(node)) {\r\n\t\t\tnode.$1 = ref.$3;\r\n\t\t} else {\r\n\t\t\tnode.$3.$1 = ref.$3;\r\n\t\t}\r\n\t\t// 4. point ref's closer to node\r\n\t\tref.$3.$2 = node;\r\n\t} else {\r\n\t\tinsertAfter(node,lastChild(ref));\r\n\t}\r\n\treturn node;\r\n}\r\n\r\n/**\r\n * insert node before ref (sibling)\r\n * @param  {Object} node Node-formatted object\r\n * @param  {Object} ref  Node-formatted object\r\n * @return {Object}      The inserted node\r\n */\r\nexport function insertBefore(node,ref) {\r\n\tconst prev = ref.$2;\r\n\tif(prev) {\r\n\t\t// replace prev's $1 with node\r\n\t\tif(isBranch(prev)) {\r\n\t\t\tprev.$3.$1 = node;\r\n\t\t} else {\r\n\t\t\tprev.$1 = node;\r\n\t\t}\r\n\t\t// point back to prev\r\n\t\tnode.$2 = prev;\r\n\t}\r\n\t// update forward pointers\r\n\tif(node.$0 === BRANCH) {\r\n\t\tnode.$3.$1 = ref;\r\n\t} else {\r\n\t\tnode.$1 = ref;\r\n\t}\r\n\t// update ref's back pointer to node\r\n\tref.$2 = node;\r\n\treturn node;\r\n}\r\n\r\n/**\r\n * insert node after ref (sibling)\r\n * @param  {Object} node Node-formatted object\r\n * @param  {Object} ref  Node-formatted object\r\n * @return {Object}      The inserted node\r\n */\r\nexport function insertAfter(node,ref) {\r\n\tconst refIsBranch = ref.$0 === BRANCH;\r\n\t// get parent's closer\r\n\tconst next = refIsBranch ? ref.$3.$1 : ref.$1;\r\n\t// point parent's closer to node\r\n\tif(next) {\r\n\t\tnext.$2 = node;\r\n\t\t// point node's next to next\r\n\t\tif(node.$0 === BRANCH) {\r\n\t\t\tnode.$3.$1 = next;\r\n\t\t} else {\r\n\t\t\tnode.$1 = next;\r\n\t\t}\r\n\t}\r\n\r\n\tif(refIsBranch) {\r\n\t\t// point ref's next to node\r\n\t\tref.$3.$1 = node;\r\n\t\t// point node back to ref\r\n\t\tnode.$2 = ref.$3;\r\n\t} else {\r\n\t\t// point ref's next to node\r\n\t\tref.$1 = node;\r\n\t\t// point node back to ref\r\n\t\tnode.$2 = ref;\r\n\t}\r\n\treturn node;\r\n}\r\n\r\n/**\r\n * Test if node is last child\r\n * @param  {Object} node Node-formatted object\r\n * @return {Boolean}      The inserted node\r\n */\r\nexport const isLastChild = node => !!node && isClose(isLeaf(node) ? node.$1 : node.$3.$1);\r\n\r\n/**\r\n * Test if node is first child\r\n * @param  {Object} node Node-formatted object\r\n * @return {Boolean}      The inserted node\r\n */\r\nexport const isFirstChild = node => !!node && node.$2.$0 === BRANCH;\r\n\r\n/**\r\n * Test if node is empty branch\r\n * @param  {Object} node Node-formatted object\r\n * @return {Boolean}      The inserted node\r\n */\r\nexport const isEmptyBranch = node => isBranch(node) && node.$1 === node.$3;\r\n\r\n/**\r\n * Retrieve the branch's closer, or the closer's branch\r\n * @param  {Object} node Node-formatted object\r\n * @return {Object|void}      Node-formatted object (if any)\r\n */\r\nexport const link = node => node && node.$3;\r\n\r\n/**\r\n * remove child from node\r\n * @param  {Object} node Node-formatted object\r\n * @param  {Object} ref  Node-formatted object\r\n * @return {Object}      The provided branch node\r\n */\r\nexport function removeChild(node,child) {\r\n\t// TODO guards!\r\n\tif(isLastChild(child)) {\r\n\t\t// last child\r\n\t\tconst prev = child.$2;\r\n\t\tprev.$1 = node.$3;\r\n\t} else {\r\n\t\tconst next = nextSibling(child);\r\n\t\tif(isFirstChild(child)) {\r\n\t\t\t// child is first, attach next to node\r\n\t\t\tnext.$2 = node;\r\n\t\t\t// set new first child\r\n\t\t\tnode.$1 = next;\r\n\t\t} else {\r\n\t\t\tconst prev = child.$2;\r\n\t\t\tprev.$1 = next;\r\n\t\t\tnext.$2 = prev;\r\n\t\t}\r\n\t}\r\n\treturn isEmptyBranch(node) ? _demote(node) : node;\r\n}\r\n\r\n/**\r\n * remove node from its parent\r\n * @param  {Object} node Node-formatted object\r\n * @return {Object}      The previous node in traversal (not closers)\r\n */\r\nexport function remove(node) {\r\n\t// TODO guards!\r\n\tconst prev = previous(node);\r\n\tif(isFirstChild(node)) {\r\n\t\tremoveChild(node.$2,node);\r\n\t} else if(isLastChild(node)) {\r\n\t\tremoveChild(node.$1.$3,node);\r\n\t} else {\r\n\t\t// splice out\r\n\t\tprev.$1 = node;\r\n\t\tnode.$2 = prev;\r\n\t\treturn prev;\r\n\t}\r\n\treturn isClose(prev) ? link(prev) : prev;\r\n}\r\n"],"file":"chimp.js"}